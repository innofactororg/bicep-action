# pipeline version: beta6
trigger: none
pr:
  autoCancel: true
  drafts: false

name: Azure Deploy

variables:
  azure_providers: Microsoft.Advisor,Microsoft.AlertsManagement,Microsoft.Authorization,Microsoft.Consumption,Microsoft.EventGrid,microsoft.insights,Microsoft.ManagedIdentity,Microsoft.Management,Microsoft.Network,Microsoft.PolicyInsights,Microsoft.ResourceHealth,Microsoft.Resources,Microsoft.Security
  azure_provider_wait_seconds: 10
  azure_provider_wait_count: 30
  azure_subscription_id: ceac59a3-67af-474b-ac4a-67ee18414df1
  cost_threshold: -1
  currency: EUR
  environment: production
  location: westeurope
  log_severity: INFO
  management_group:
  resource_group:
  rule_baseline: Azure.Default
  rule_modules: Az.Resources,PSRule.Rules.Azure
  rule_option: ps-rule.yaml
  scope: sub
  serviceConnection: ifsandboxvdc01_arm_connection
  template: main.bicep
  template_parameters: main.bicepparam
  version_ace_tool: 1.4

pool:
  vmImage: ubuntu-22.04

stages:
  - stage: Plan
    jobs:
      - job: plan
        displayName: Plan deployment
        steps:
          - checkout: self
            displayName: Checkout
            fetchDepth: 1
            persistCredentials: true

          - task: AzureCLI@2
            displayName: Install tools
            env:
              IN_SEVERITY: ${{ variables.log_severity }}
              IN_TEMPLATE: ${{ variables.template }}
              LOG_NAME: install_tools
              LOG_PATH: $(Pipeline.Workspace)/logs
            name: install_tools
            inputs:
              azureSubscription: ${{ variables.serviceConnection }}
              scriptLocation: inlineScript
              scriptType: bash
              inlineScript: |
                set -e
                mkdir -p "${LOG_PATH}"
                log="${LOG_PATH}/step_b1_${LOG_NAME}.log"
                trap 'error $? $LINENO "$BASH_COMMAND" $log' ERR
                error() {
                  local msg="Error on or near line $(expr $2 + 1) (exit code $1)"
                  msg+=" in ${LOG_NAME} at $(date '+%Y-%m-%d %H:%M:%S')"
                  echo "${msg}"
                  log_output "$4" "${msg}" "$3"
                  exit $1
                }
                log_output() {
                  local summary="${2}❗"
                  if test -n "${3}"; then
                    summary+="\n\nCommand that failed:\n${3}"
                  fi
                  local data=$(cat "${1}" 2>/dev/null || true)
                  local output="## Install tools\n\n${summary}"
                  if test -n "${data}"; then
                    output+='\n\n```text\n'
                    output+="${data}\n"
                    output+='```'
                  fi
                  echo -e "${output}" > "${1/.log/.md}"
                }
                az_version=$(az version | jq -r '."azure-cli"')
                echo "Azure CLI ${az_version}" | tee -a "${log}"
                echo 'Installed extensions:' | tee -a "${log}"
                az version --query extensions -o yaml | tee -a "${log}"
                if [[ $IN_TEMPLATE == *.bicep ]]; then
                  az config set bicep.use_binary_from_path=False >/dev/null 2>&1
                  cmd="az bicep install"
                  case "${IN_SEVERITY}" in
                    ERROR)   cmd+=' --only-show-errors';;
                    VERBOSE) cmd+=' --verbose';;
                    DEBUG)   cmd+=' --debug';;
                  esac
                  echo "Run: ${cmd}"
                  eval "${cmd}" 1> >(tee -a "${log}") 2> >(tee -a "${log}" >&2)
                fi

          - task: AzureCLI@2
            condition: and(succeeded(), not(startsWith(variables['template'], '/subscriptions/')))
            displayName: Bicep build
            env:
              IN_SEVERITY: ${{ variables.log_severity }}
              IN_TEMPLATE: ${{ variables.template }}
              LOG_NAME: bicep_build
              LOG_PATH: $(Pipeline.Workspace)/logs
              SOURCE_PATH: $(Build.SourcesDirectory)
            name: bicep_build
            inputs:
              azureSubscription: ${{ variables.serviceConnection }}
              scriptLocation: inlineScript
              scriptType: bash
              inlineScript: |
                set -e
                log="${LOG_PATH}/step_b3_${LOG_NAME}.log"
                trap 'error $? $LINENO "$BASH_COMMAND" $log' ERR
                error() {
                  local msg="Error on or near line $(expr $2 + 1) (exit code $1)"
                  msg+=" in ${LOG_NAME} at $(date '+%Y-%m-%d %H:%M:%S')"
                  echo "${msg}"
                  log_output "$4" "${msg}" "$3"
                  exit $1
                }
                log_output() {
                  local errors=''
                  local summary=''
                  local warnings=''
                  if test -f "${1}"; then
                    local data=$(cat "${1}")
                    data=$(echo "${data//${SOURCE_PATH}/}")
                    warnings=$(echo "${data}" | sed -n -e '/) : Warning /p')
                    warnings=$(echo "${warnings//WARNING: /}")
                    errors=$(echo "${data}" | sed -n -e '/) : Error /p')
                    errors=$(echo "${errors//ERROR: /}")
                  fi
                  if test -n "${errors}" || test -n "${2}"; then
                    summary="The ${LOG_NAME} failed❗ ${2}"
                    if test -n "${3}"; then
                      summary+="\n\nCommand that failed:\n${3}"
                    fi
                  elif test -n "${warnings}"; then
                    summary="Notice the ${LOG_NAME} warning ✋"
                  fi
                  if test -n "${summary}"; then
                    local output="## Bicep build\n\n${summary}"
                    if test -n "${warnings}"; then
                      output+='\n\nWARNINGS:\n\n```text\n'
                      output+="${warnings}\n"
                      output+='```'
                    fi
                    if test -n "${errors}"; then
                      output+='\n\nERRORS:\n\n```text\n'
                      output+="${errors}\n"
                      output+='```'
                    fi
                    echo -e "${output}" > "${1/.log/.md}"
                  fi
                }
                if [[ $IN_TEMPLATE == http* ]]; then
                  echo "Download ${IN_TEMPLATE}"
                  curl -o "${IN_TEMPLATE##*/}" -sSL "${IN_TEMPLATE}" 1> >(tee -a "${log}") 2> >(tee -a "${log}" >&2)
                  IN_TEMPLATE="${IN_TEMPLATE##*/}"
                fi
                if [[ $IN_TEMPLATE != /subscriptions/* ]]; then
                  out_file=$(readlink -f "${IN_TEMPLATE/.bicep/.json}")
                  if [[ $IN_TEMPLATE == *.bicep ]]; then
                    cmd="az bicep build --file ${IN_TEMPLATE} --outfile ${out_file}"
                    case "${IN_SEVERITY}" in
                      ERROR)   cmd+=' --only-show-errors';;
                      VERBOSE) cmd+=' --verbose';;
                      DEBUG)   cmd+=' --debug';;
                    esac
                    echo "Run: ${cmd}"
                    eval "${cmd}" 1> >(tee -a "${log}") 2> >(tee -a "${log}" >&2)
                    if test -f "${out_file}"; then
                      cp ${out_file} ${LOG_PATH}/
                    fi
                  else
                    echo "Skip bicep build, not a bicep file: ${IN_TEMPLATE}"
                  fi
                else
                  out_file=''
                fi
                echo "##vso[task.setvariable variable=${LOG_NAME}_file]${out_file}"
                log_output "${log}" '' ''

          - task: AzureCLI@2
            condition: and(succeeded(), not(eq(variables['template_parameters'], '')))
            displayName: Bicep build params
            env:
              IN_SEVERITY: ${{ variables.log_severity }}
              IN_TEMPLATE: ${{ variables.template_parameters }}
              LOG_NAME: bicep_build_params
              LOG_PATH: $(Pipeline.Workspace)/logs
              SOURCE_PATH: $(Build.SourcesDirectory)
            name: bicep_build_params
            inputs:
              azureSubscription: ${{ variables.serviceConnection }}
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                set -e
                log="${LOG_PATH}/step_b4_${LOG_NAME}.log"
                trap 'error $? $LINENO "$BASH_COMMAND" $log' ERR
                error() {
                  local msg="Error on or near line $(expr $2 + 1) (exit code $1)"
                  msg+=" in ${LOG_NAME} at $(date '+%Y-%m-%d %H:%M:%S')"
                  echo "${msg}"
                  log_output "$4" "${msg}" "$3"
                  exit $1
                }
                log_output() {
                  local errors=''
                  local summary=''
                  local warnings=''
                  if test -f "${1}"; then
                    local data=$(cat "${1}")
                    data=$(echo "${data//${SOURCE_PATH}/}")
                    warnings=$(echo "${data}" | sed -n -e '/) : Warning /p')
                    warnings=$(echo "${warnings//WARNING: /}")
                    errors=$(echo "${data}" | sed -n -e '/) : Error /p')
                    errors=$(echo "${errors//ERROR: /}")
                  fi
                  if test -n "${errors}" || test -n "${2}"; then
                    summary="The ${LOG_NAME} failed❗ ${2}"
                    if test -n "${3}"; then
                      summary+="\n\nCommand that failed:\n${3}"
                    fi
                  elif test -n "${warnings}"; then
                    summary="Notice the ${LOG_NAME} warning ✋"
                  fi
                  if test -n "${summary}"; then
                    local output="## Bicep build-params\n\n${summary}"
                    if test -n "${warnings}"; then
                      output+='\n\nWARNINGS:\n\n```text\n'
                      output+="${warnings}\n"
                      output+='```'
                    fi
                    if test -n "${errors}"; then
                      output+='\n\nERRORS:\n\n```text\n'
                      output+="${errors}\n"
                      output+='```'
                    fi
                    echo -e "${output}" > "${1/.log/.md}"
                  fi
                }
                IN_TEMPLATE="${IN_TEMPLATE%% *}"
                if [[ $IN_TEMPLATE == http* ]]; then
                  echo "Download ${IN_TEMPLATE}"
                  curl -o "${IN_TEMPLATE##*/}" -sSL "${IN_TEMPLATE}" 1> >(tee -a "${log}") 2> >(tee -a "${log}" >&2)
                  IN_TEMPLATE="${IN_TEMPLATE##*/}"
                fi
                out_file=$(readlink -f "${IN_TEMPLATE/.bicepparam/.parameters.json}")
                if [[ $IN_TEMPLATE == *.bicepparam ]]; then
                  cmd="az bicep build-params --file ${IN_TEMPLATE} --outfile ${out_file}"
                  case "${IN_SEVERITY}" in
                    ERROR)   cmd+=' --only-show-errors';;
                    VERBOSE) cmd+=' --verbose';;
                    DEBUG)   cmd+=' --debug';;
                  esac
                  echo "Run: ${cmd}"
                  eval "${cmd}" 1> >(tee -a "${log}") 2> >(tee -a "${log}" >&2)
                  if test -f "${out_file}"; then
                    cp ${out_file} ${LOG_PATH}/
                  fi
                else
                  echo "Skip bicep build-params, not a bicepparam file: ${IN_TEMPLATE}"
                fi
                echo "##vso[task.setvariable variable=${LOG_NAME}_file]${out_file}"

          - task: AzureCLI@2
            displayName: Validate
            env:
              IN_LOCATION: ${{ variables.location }}
              IN_MANAGEMENT_GROUP: ${{ variables.management_group }}
              IN_PROVIDERS: ${{ variables.azure_providers }}
              IN_RESOURCE_GROUP: ${{ variables.resource_group }}
              IN_SCOPE: ${{ variables.scope }}
              IN_SEVERITY: ${{ variables.log_severity }}
              IN_TEMPLATE: ${{ variables.template }}
              IN_TEMPLATE_PARAMS: ${{ variables.template_parameters }}
              LOG_NAME: validate
              LOG_PATH: $(Pipeline.Workspace)/logs
              RUN_ID: $(Build.BuildId)
              SOURCE_PATH: $(Build.SourcesDirectory)
              SUBSCRIPTION_ID: ${{ variables.azure_subscription_id }}
            name: validate
            inputs:
              azureSubscription: ${{ variables.serviceConnection }}
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                set -e
                log="${LOG_PATH}/step_b5_${LOG_NAME}.log"
                trap 'error $? $LINENO "$BASH_COMMAND" $log' ERR
                error() {
                  local msg="Error on or near line $(expr $2 + 1) (exit code $1)"
                  msg+=" in ${LOG_NAME} at $(date '+%Y-%m-%d %H:%M:%S')"
                  echo "${msg}"
                  log_output "$4" "${msg}" "$3"
                  exit $1
                }
                log_output() {
                  local errors=''
                  local from_code=''
                  local json_object=''
                  local summary=''
                  local warnings=''
                  if test -f "${1}"; then
                    json_object=$(sed -n '/^{$/,$p' "${1}")
                    local data=$(sed '/^{$/,$d' "${1}")
                    data=$(echo "${data//${SOURCE_PATH}/}")
                    warnings=$(echo "${data}" | sed -n -e '/) : Warning /p')
                    warnings=$(echo "${warnings//WARNING: /}")
                    errors=$(echo "${data}" | sed -n '/^ERROR: /,$p')
                    errors=$(echo "${errors//ERROR: /}")
                    if [[ "${json_object}" == {* ]]; then
                      from_code=$(
                        echo "${json_object}" | \
                          jq '.properties.providers | map(.namespace) | join(" ")'
                      )
                      echo "Resource providers discovered by ${LOG_NAME}:"
                      echo "${from_code}"
                    fi
                  fi
                  if test -n "${errors}" || test -n "${2}"; then
                    summary="The ${LOG_NAME} failed❗ ${2}"
                    if test -n "${3}"; then
                      summary+="\n\nCommand that failed:\n${3}"
                    fi
                  elif test -n "${warnings}"; then
                    summary="Notice the ${LOG_NAME} warning ✋"
                  elif test -z "${json_object}"; then
                    summary="The ${LOG_NAME} failed❗ No output found."
                  fi
                  if test -n "${summary}"; then
                    summary="\n\n${summary}"
                  fi
                  local output="## Validate${summary}"
                  if test -n "${warnings}"; then
                    output+='\n\nWARNINGS:\n\n```text\n'
                    output+="${warnings}\n"
                    output+='```'
                  fi
                  if test -n "${errors}"; then
                    output+='\n\nERRORS:\n\n```text\n'
                    output+="${errors}\n"
                    output+='```'
                  fi
                  if test -n "${json_object}"; then
                    output+='\n\n<details><summary>Click for details</summary>\n'
                    output+='\n```json\n'
                    output+="${json_object}\n"
                    output+='```\n\n</details>'
                  fi
                  echo -e "${output}" > "${1/.log/.md}"
                  local list=$(echo "${IN_PROVIDERS} ${from_code}" | xargs | sed 's/,/ /g')
                  echo "##vso[task.setvariable variable=providers;isOutput=true]${list}"
                }
                az account set -s ${SUBSCRIPTION_ID} 1> >(tee -a "${log}") 2> >(tee -a "${log}" >&2)
                if [[ $IN_TEMPLATE_PARAMS == http* ]]; then
                  file="${IN_TEMPLATE_PARAMS%% *}"
                  curl -o "${file##*/}" -sSL "${file}" 1> >(tee -a "${log}") 2> >(tee -a "${log}" >&2)
                  IN_TEMPLATE_PARAMS="${IN_TEMPLATE_PARAMS/${file}/${file##*/}}"
                fi
                cmd="az deployment ${IN_SCOPE} validate --name ${LOG_NAME}_${RUN_ID}"
                if [[ $IN_TEMPLATE == http* ]]; then
                  cmd+=" --template-uri ${IN_TEMPLATE}"
                elif [[ $IN_TEMPLATE == /subscriptions/* ]]; then
                  cmd+=" --template-spec ${IN_TEMPLATE}"
                else
                  cmd+=" --template-file ${IN_TEMPLATE}"
                fi
                if test -n "${IN_TEMPLATE_PARAMS}"; then
                  cmd+=" --parameters ${IN_TEMPLATE_PARAMS}"
                fi
                if ! [ "${IN_SCOPE}" = 'group' ]; then
                  cmd+=" --location ${IN_LOCATION}"
                fi
                if [ "${IN_SCOPE}" = 'mg' ]; then
                  cmd+=" --management-group-id ${IN_MANAGEMENT_GROUP}"
                fi
                if [ "${IN_SCOPE}" = 'group' ]; then
                  cmd+=" --resource-group ${IN_RESOURCE_GROUP}"
                fi
                case "${IN_SEVERITY}" in
                  ERROR)   cmd+=' --only-show-errors';;
                  VERBOSE) cmd+=' --verbose';;
                  DEBUG)   cmd+=' --debug';;
                esac
                cmd+=' --no-prompt true -o json'
                echo "Run: ${cmd}"
                eval "${cmd}" 1> >(tee -a "${log}") 2> >(tee -a "${log}" >&2)
                log_output "${log}" '' ''

          - task: AzureCLI@2
            displayName: What-if
            env:
              IN_LOCATION: ${{ variables.location }}
              IN_MANAGEMENT_GROUP: ${{ variables.management_group }}
              IN_RESOURCE_GROUP: ${{ variables.resource_group }}
              IN_SCOPE: ${{ variables.scope }}
              IN_SEVERITY: ${{ variables.log_severity }}
              IN_TEMPLATE: ${{ variables.template }}
              IN_TEMPLATE_PARAMS: ${{ variables.template_parameters }}
              LOG_NAME: what-if
              LOG_PATH: $(Pipeline.Workspace)/logs
              RUN_ID: $(Build.BuildId)
              RUN_NAME: $(Build.BuildNumber)
              RUN_NUMBER: $(Build.BuildId)
              SUBSCRIPTION_ID: ${{ variables.azure_subscription_id }}
            name: what-if
            inputs:
              azureSubscription: ${{ variables.serviceConnection }}
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                set -e
                log="${LOG_PATH}/step_a1_${LOG_NAME}.log"
                trap 'error $? $LINENO "$BASH_COMMAND" $log' ERR
                error() {
                  local msg="Error on or near line $(expr $2 + 1) (exit code $1)"
                  msg+=" in ${LOG_NAME} at $(date '+%Y-%m-%d %H:%M:%S')"
                  echo "${msg}"
                  log_output "$4" "${msg}" "$3"
                  exit $1
                }
                log_output() {
                  local data=''
                  local summary=''
                  if test -f "${1}"; then
                    data=$(
                      sed -r 's/^([[:space:]]+)([-+~x])[[:space:]]/\2\1/g' "${1}" | \
                      sed -e 's/^~/!/g'
                    )
                  fi
                  if test -n "${2}"; then
                    summary=" ${2}"
                    if test -n "${3}"; then
                      summary+="\n\nCommand that failed:\n${3}"
                    fi
                  elif test -z "${data}"; then
                    summary=" No output found."
                  fi
                  local output="# Plan for ${RUN_NAME} #${RUN_NUMBER}\n\n_JOB_STATUS_${summary}"
                  if test -n "${data}"; then
                    if [ ${#data} -gt 5000 ]; then
                      output+='\n\n<details><summary>Click for details</summary>'
                    fi
                    output+='\n\n```diff\n'
                    output+="${data}\n"
                    output+='```'
                    if [ ${#data} -gt 5000 ]; then
                      output+='\n\n</details>'
                    fi
                  fi
                  echo -e "${output}" > "${1/.log/.md}"
                }
                az account set -s ${SUBSCRIPTION_ID} 1> >(tee -a "${log}") 2> >(tee -a "${log}" >&2)
                if [[ $IN_TEMPLATE == http* ]]; then
                  IN_TEMPLATE="${IN_TEMPLATE##*/}"
                fi
                if [[ $IN_TEMPLATE_PARAMS == http* ]]; then
                  file="${IN_TEMPLATE_PARAMS%% *}"
                  IN_TEMPLATE_PARAMS="${IN_TEMPLATE_PARAMS/${file}/${file##*/}}"
                fi
                cmd="az deployment ${IN_SCOPE} what-if --name ${LOG_NAME}_${RUN_ID}"
                if [[ $IN_TEMPLATE == http* ]]; then
                  cmd+=" --template-uri ${IN_TEMPLATE}"
                elif [[ $IN_TEMPLATE == /subscriptions/* ]]; then
                  cmd+=" --template-spec ${IN_TEMPLATE}"
                else
                  cmd+=" --template-file ${IN_TEMPLATE}"
                fi
                if test -n "${IN_TEMPLATE_PARAMS}"; then
                  cmd+=" --parameters ${IN_TEMPLATE_PARAMS}"
                fi
                if ! [ "${IN_SCOPE}" = 'group' ]; then
                  cmd+=" --location ${IN_LOCATION}"
                fi
                if [ "${IN_SCOPE}" = 'mg' ]; then
                  cmd+=" --management-group-id ${IN_MANAGEMENT_GROUP}"
                fi
                if [ "${IN_SCOPE}" = 'group' ]; then
                  cmd+=" --resource-group ${IN_RESOURCE_GROUP}"
                fi
                case "${IN_SEVERITY}" in
                  ERROR)   cmd+=' --only-show-errors';;
                  VERBOSE) cmd+=' --verbose';;
                  DEBUG)   cmd+=' --debug';;
                esac
                cmd+=' --exclude-change-types Ignore NoChange --no-prompt true'
                echo "Run: ${cmd}"
                eval "${cmd}" 1> >(tee -a "${log}") 2> >(tee -a "${log}" >&2)
                log_output "${log}" '' ''

          - task: Bash@3
            condition: and(succeeded(), not(eq(variables['rule_option'], '')))
            displayName: PSRule config
            env:
              LOG_NAME: psrule_config
              OPTION: ${{ variables.rule_option }}
              TEMPLATE_FILE: $(bicep_build_file)
              TEMPLATE_PARAMS_FILE: $(bicep_build_params_file)
            name: psrule_config
            inputs:
              targetType: inline
              script: |
                set -e
                missing=''
                if ! test -f "${OPTION}"; then
                  missing="Unable to find rule_option file ${OPTION}"
                else
                  echo "Use PSRule config at ${OPTION}"
                  if test -n "${TEMPLATE_FILE}" && [[ $TEMPLATE_PARAMS_FILE == *.parameters.json ]]; then
                    file=$TEMPLATE_PARAMS_FILE
                    t=$(basename "${TEMPLATE_FILE}")
                    p=$(basename "${file}")
                    if [ "${t/.json/}" != "${p/.parameters.json/}" ]; then
                      meta=$(jq -r '.metadata | select (.!=null)' $file)
                      if test -z "${meta}"; then
                        json=$(jq --arg t $t '. += {metadata:{template:$t}}' $file)
                        if test -n "${json}"; then
                          printf '%s\n' "${json}" >$file
                        fi
                      else
                        json=$(jq --arg t $t '.metadata += {template:$t}' $file)
                        if test -n "${json}"; then
                          printf '%s\n' "${json}" >$file
                        fi
                      fi
                    fi
                  fi
                fi
                echo "##vso[task.setvariable variable=${LOG_NAME}_error]${missing}"
                if test -n "${missing}"; then
                  echo "${msg}"
                  exit 1
                fi

          - task: ps-rule-assert@2
            condition: and(succeeded(), not(eq(variables['rule_option'], '')), eq(variables['psrule_config_error'], ''))
            displayName: PSRule analysis
            name: psrule_analysis
            inputs:
              baseline: ${{ variables.rule_baseline }}
              inputPath: $(Build.SourcesDirectory)
              inputType: repository
              modules: ${{ variables.rule_modules }}
              option: ${{ variables.rule_option }}
              outputFormat: Markdown
              outputPath: $(Pipeline.Workspace)/logs/psrule_analysis.md
              summary: false

          - task: Bash@3
            condition: and(not(eq(variables['rule_option'], '')), or(succeeded(), failed()))
            displayName: PSRule report
            env:
              CONFIG_ERROR: $(psrule_config_error)
              LOG_NAME: psrule_report
              LOG_PATH: $(Pipeline.Workspace)/logs
            name: psrule_report
            inputs:
              targetType: inline
              script: |
                output=''
                if test -n "${CONFIG_ERROR}"; then
                  output='## PSRule\n\n'
                  output+="${CONFIG_ERROR}❗"
                elif test -f "${LOG_PATH}/psrule_analysis.md"; then
                  data=$(cat "${LOG_PATH}/psrule_analysis.md")
                  if test -z "${data}" || [ "${data}" = '# PSRule' ]; then
                    echo 'PSRule report is empty'
                  else
                    current_pwd="$(pwd)/"
                    output='## PSRule'
                    if test -f psrule_summary.md; then
                      summary=$(
                        sed -e ':a' -e 'N' -e '$!ba' psrule_summary.md \
                          -e 's|# PSRule result summary\n\n||g' \
                          -e 's|## |### |g'
                      )
                      if test -n "${summary}"; then
                        output+="\n\n${summary}"
                        mv -f psrule_summary.md "${LOG_PATH}/"
                      fi
                    fi
                    data=$(
                      echo "${data}" | sed -e ':a' -e 'N' -e '$!ba' \
                      -e 's|# PSRule\n\n||g' \
                      -e 's|## |### |g' \
                      -e "s|${current_pwd}||g"
                    )
                    if test -n "${data}"; then
                      output+='\n\n<details><summary>Click for details</summary>'
                      output+="\n\n${data}\n\n</details>"
                    fi
                    echo 'PSRule report created'
                  fi
                fi
                if test -n "${output}"; then
                  echo -e "${output}" > "${LOG_PATH}/step_b6_${LOG_NAME}.md"
                fi

          - task: AzureCLI@2
            condition: and(succeeded(), not(eq(variables['bicep_build_file'], '')))
            displayName: Cost estimate
            env:
              IN_CURRENCY: ${{ variables.currency }}
              IN_LOCATION: ${{ variables.location }}
              IN_MANAGEMENT_GROUP: ${{ variables.management_group }}
              IN_RESOURCE_GROUP: ${{ variables.resource_group }}
              IN_SCOPE: ${{ variables.scope }}
              IN_TEMPLATE_PARAMS: ${{ variables.template_parameters }}
              LOG_NAME: cost_estimate
              LOG_PATH: $(Pipeline.Workspace)/logs
              SUBSCRIPTION_ID: ${{ variables.azure_subscription_id }}
              TEMPLATE_FILE: $(bicep_build_file)
              TEMPLATE_PARAMS_FILE: $(bicep_build_params_file)
              THRESHOLD: ${{ variables.cost_threshold }}
              VERSION_ACE: ${{ variables.version_ace_tool }}
            name: cost_estimate
            inputs:
              azureSubscription: ${{ variables.serviceConnection }}
              scriptLocation: inlineScript
              scriptType: bash
              inlineScript: |
                set -e
                log="${LOG_PATH}/step_a2_${LOG_NAME}.log"
                trap 'error $? $LINENO "$BASH_COMMAND" $log' ERR
                error() {
                  local msg="Error on or near line $(expr $2 + 1) (exit code $1)"
                  msg+=" in ${LOG_NAME} at $(date '+%Y-%m-%d %H:%M:%S')"
                  echo "${msg}"
                  log_output "$4" "${msg}" "$3"
                  exit $1
                }
                log_output() {
                  local data=''
                  local output=''
                  local over=''
                  local summary=''
                  if test -f "${1}"; then
                    data=$(cat "${1}")
                  fi
                  if test -n "${2}"; then
                    summary="The ${LOG_NAME} failed❗ ${2}"
                    if test -n "${3}"; then
                      summary+="\n\nCommand that failed:\n${3}"
                    fi
                  elif test -z "${data}"; then
                    summary="The ${LOG_NAME} failed❗ No output found."
                  fi
                  if test -n "${summary}"; then
                    summary="\n\n${summary}"
                  fi
                  local output="## Cost estimate${summary}"
                  local file="${LOG_NAME}.json"
                  if test -f "${file}"; then
                    mv -f "${file}" "${LOG_PATH}/"
                    file="${LOG_PATH}/${LOG_NAME}.json"
                    local total=$(jq -r '.TotalCost.Value | select (.!=null)' ${file})
                    local delta=$(jq -r '.Delta.Value | select (.!=null)' ${file})
                    local currency=$(jq -r '.Currency | select (.!=null)' ${file})
                    local txt=''
                    if [ "${total}" != "${delta}" ]; then
                      if [ "${delta}" = '0.00' ]; then
                        txt='No cost change detected! '
                      elif [[ "${delta}" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
                        if [ $(echo "${delta} > 0" | bc -l) -eq 1 ]; then
                          txt="Estimated increase is +${delta} ${currency}! "
                        else
                          txt="Estimated decrease is -${delta} ${currency}! "
                        fi
                      fi
                      if [[ "${total}" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
                        txt+="Total estimated cost is ${total} ${currency}."
                      fi
                    elif [ "${total}" = '0.00' ]; then
                      txt='No cost detected!'
                    elif [[ "${total}" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
                      txt="Estimated cost increase is +${total} ${currency}!"
                    fi
                    if [[ "${THRESHOLD}" =~ ^[0-9]+(\.[0-9]+)?$ ]] && \
                      [[ "${total}" =~ ^[0-9]+(\.[0-9]+)?$ ]] && \
                      [ $(echo "${total} > ${THRESHOLD}" | bc -l) -eq 1 ]
                    then
                      over="Total estimated cost exceeds ${THRESHOLD} ${currency}❗"
                      txt+="\n\n${over}"
                    fi
                    output+="\n\n${txt}"
                  fi
                  if test -n "${data}"; then
                    output+='\n\n<details><summary>Click for details</summary>'
                    output+='\n\n```text\n'
                    output+="${data}\n"
                    output+='```\n'
                    output+='\n</details>'
                  fi
                  echo -e "${output}" > "${1/.log/.md}"
                  if test -n "${over}"; then
                    echo "##[error]${over}"
                    if test -z "${2}"; then
                      exit 1
                    fi
                  fi
                }
                if ! test -f "${TEMPLATE_FILE}"; then
                  echo "Skip: Unable to find ${TEMPLATE_FILE}."
                  exit 1
                fi
                cmd='./708gyals2sgas/azure-cost-estimator'
                file='linux-x64.zip'
                url='https://github.com/TheCloudTheory/arm-estimator/'
                url+="releases/download/${VERSION_ACE}/${file}"
                mkdir -p "708gyals2sgas"
                echo "Run: curl -o 708gyals2sgas/${file} -sSL ${url}"
                curl -o 708gyals2sgas/${file} -sSL ${url}
                unzip -q 708gyals2sgas/${file} -d 708gyals2sgas
                chmod +x ./708gyals2sgas/azure-cost-estimator
                PATH=$PATH:$(readlink -f 708gyals2sgas/)
                case "${IN_SCOPE}" in
                  tenant) cmd+=" ${IN_SCOPE} ${TEMPLATE_FILE} ${IN_LOCATION}";;
                  mg)     cmd+=" ${IN_SCOPE} ${TEMPLATE_FILE} ${IN_MANAGEMENT_GROUP} ${IN_LOCATION}";;
                  sub)    cmd+=" ${IN_SCOPE} ${TEMPLATE_FILE} ${SUBSCRIPTION_ID} ${IN_LOCATION}";;
                  group)  cmd+=" ${TEMPLATE_FILE} ${SUBSCRIPTION_ID} ${IN_RESOURCE_GROUP}";;
                esac
                if [[ $TEMPLATE_PARAMS_FILE == *.parameters.json ]]; then
                  cmd+=" --parameters ${TEMPLATE_PARAMS_FILE}"
                fi
                if [[ $IN_TEMPLATE_PARAMS == *=* ]]; then
                  param_list=($IN_TEMPLATE_PARAMS)
                  for pair in "${param_list[@]}"; do
                    if test -n "${pair%=*}" && [[ "${pair}" == *=* ]]; then
                      cmd+=" --inline ${pair%=*}=${pair#*=}"
                    fi
                  done
                fi
                cmd+=" --currency ${IN_CURRENCY}"
                cmd+=' --disable-cache --generateJsonOutput'
                cmd+=" --jsonOutputFilename ${LOG_NAME}"
                echo "Run: ${cmd}"
                eval "${cmd}" 1> >(tee -a "${log}") 2> >(tee -a "${log}" >&2)
                log_output "${log}" '' ''

          - task: Bash@3
            condition: and(always(), eq(variables['Build.Reason'], 'PullRequest'))
            displayName: Add comment
            env:
              COMMENTS_URL: $(System.CollectionUri)$(System.TeamProject)/_apis/git/repositories/$(Build.Repository.Name)/pullRequests/$(System.PullRequest.PullRequestId)/threads?api-version=7.1-preview.1
              JOB_STATUS: $(Agent.JobStatus)
              LOG_PATH: $(Pipeline.Workspace)/logs
              RUN_NUMBER: $(Build.BuildId)
              RUN_URL: $(Build.BuildUri)
              TOKEN: $(System.AccessToken)
            name: add_comment
            inputs:
              targetType: inline
              script: |
                set -e
                add_output() {
                  local add=''
                  local data=''
                  local name=''
                  local step=''
                  local output=''
                  while read -r file; do
                    data=$(cat "${file}")
                    if test -n "${data}"; then
                      name=$(basename "${file}")
                      name=${name:8}
                      name=${name/_/ }
                      name=${name/psrule/PSRule}
                      name=${name/.md/}
                      name="$(tr '[:lower:]' '[:upper:]' <<< ${name:0:1})${name:1}"
                      step=$(printf '%20s' "'${name}'")
                      add=$(printf '%5d' ${#data})
                      if [ ${#data} -gt 63900 ]; then
                        data=$(echo -e "## ${name}\n\nThe ${name} output is too long. See job [#${RUN_NUMBER}](${RUN_URL}) for details!")
                      fi
                      if test -z "${output}"; then
                        output=$data
                      else
                        output+=$(echo -e "\n\n${data}")
                      fi
                    fi
                  done
                  echo "$output"
                }
                output=$(find $LOG_PATH -name 'step_*.md' -maxdepth 1 -type f | sort | add_output)
                case "${JOB_STATUS}" in
                  cancelled|Canceled) title='The job was cancelled ❎';;
                  failed|Failed)      title='The job failed ⛔';;
                  *)                  title='The job completed successfully ✅';;
                esac
                if test -z "${output}"; then
                  title+=' Job output is missing ⭕'
                fi
                output="${output/_JOB_STATUS_/${title}}"
                echo "Comment has ${#output} characters."
                echo "${output}" > "${LOG_PATH}/comment.md"
                echo "##vso[task.uploadsummary]${LOG_PATH}/comment.md"
                data=$(jq --arg content "$output" '.comments[0].content = $content' <<< '{"comments": [{"parentCommentId": 0,"content": "","commentType": 1}],"status": 1}')
                HTTP_CODE=$(curl --request POST \
                  --write-out "%{http_code}" \
                  --header 'Accept: application/json' \
                  --header "Authorization: Bearer ${TOKEN}" \
                  --header 'Content-Type: application/json' \
                  --data "${data}" \
                  --url "$( echo "${COMMENTS_URL}" | sed 's/ /%20/g' )" \
                  --output "${LOG_PATH}/add_comment.log" --silent
                )
                if [[ ${HTTP_CODE} -lt 200 || ${HTTP_CODE} -gt 299 ]]; then
                  echo "Unable to create comment! Response code: ${HTTP_CODE}"
                  if test -f "${LOG_PATH}/add_comment.log"; then
                    cat "${LOG_PATH}/add_comment.log"
                  fi
                  exit 1
                fi

          - task: Bash@3
            condition: or(failed(), and(succeeded(), not(eq(variables['log_severity'], 'ERROR'))))
            displayName: Show debug info
            name: debug
            inputs:
              targetType: inline
              script: |
                set -e
                echo '##[group]environment variables'
                for var in $(compgen -e); do
                  echo "${var} ${!var}"
                done
                echo '##[endgroup]'

          - task: PublishPipelineArtifact@1
            condition: always()
            displayName: Upload logs
            name: upload_logs
            inputs:
              artifact: plan_logs
              publishLocation: pipeline
              targetPath: $(Pipeline.Workspace)/logs

  - stage: Create
    dependsOn: Plan
    jobs:
      - deployment: create
        displayName: Create deployment
        environment: ${{ variables.environment }}
        variables:
          plan_providers: $[ stageDependencies.Plan.plan.outputs['validate.providers'] ]
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: Checkout
                  fetchDepth: 1
                  persistCredentials: true

                - task: AzureCLI@2
                  displayName: Install tools
                  env:
                    IN_SEVERITY: ${{ variables.log_severity }}
                    IN_TEMPLATE: ${{ variables.template }}
                    LOG_NAME: install_tools
                    LOG_PATH: $(Pipeline.Workspace)/logs
                  name: install_tools
                  inputs:
                    azureSubscription: ${{ variables.serviceConnection }}
                    scriptLocation: inlineScript
                    scriptType: bash
                    inlineScript: |
                      set -e
                      mkdir -p "${LOG_PATH}"
                      log="${LOG_PATH}/step_b1_${LOG_NAME}.log"
                      trap 'error $? $LINENO "$BASH_COMMAND" $log' ERR
                      error() {
                        local msg="Error on or near line $(expr $2 + 1) (exit code $1)"
                        msg+=" in ${LOG_NAME} at $(date '+%Y-%m-%d %H:%M:%S')"
                        echo "${msg}"
                        log_output "$4" "${msg}" "$3"
                        exit $1
                      }
                      log_output() {
                        local summary="${2}❗"
                        if test -n "${3}"; then
                          summary+="\n\nCommand that failed:\n${3}"
                        fi
                        local data=$(cat "${1}" 2>/dev/null || true)
                        local output="## Install tools\n\n${summary}"
                        if test -n "${data}"; then
                          output+='\n\n```text\n'
                          output+="${data}\n"
                          output+='```'
                        fi
                        echo -e "${output}" > "${1/.log/.md}"
                      }
                      az_version=$(az version | jq -r '."azure-cli"')
                      echo "Azure CLI ${az_version}" | tee -a "${log}"
                      echo 'Installed extensions:' | tee -a "${log}"
                      az version --query extensions -o yaml | tee -a "${log}"
                      if [[ $IN_TEMPLATE == *.bicep ]]; then
                        az config set bicep.use_binary_from_path=False >/dev/null 2>&1
                        cmd="az bicep install"
                        case "${IN_SEVERITY}" in
                          ERROR)   cmd+=' --only-show-errors';;
                          VERBOSE) cmd+=' --verbose';;
                          DEBUG)   cmd+=' --debug';;
                        esac
                        echo "Run: ${cmd}"
                        eval "${cmd}" 1> >(tee -a "${log}") 2> >(tee -a "${log}" >&2)
                      fi

                - task: AzureCLI@2
                  condition: and(succeeded(), not(eq(variables['plan_providers'], '')))
                  displayName: Check Azure providers
                  env:
                    IN_PROVIDERS: $(plan_providers)
                    IN_SEVERITY: ${{ variables.log_severity }}
                    LOG_NAME: check_providers
                    LOG_PATH: $(Pipeline.Workspace)/logs
                    WAIT_COUNT: ${{ variables.azure_provider_wait_count }}
                    WAIT_SECONDS: ${{ variables.azure_provider_wait_seconds }}
                  name: check_providers
                  inputs:
                    azureSubscription: ${{ variables.serviceConnection }}
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      set -e
                      log="${LOG_PATH}/step_b3_${LOG_NAME}.log"
                      trap 'error_handler $? $LINENO "$BASH_COMMAND" $log' ERR
                      error_handler() {
                        local msg="Error on or near line $(expr $2 + 1) (exit code $1)"
                        msg+=" in ${LOG_NAME} at $(date '+%Y-%m-%d %H:%M:%S')"
                        echo "${msg}"
                        log_output "$4" "${msg}" "$3"
                        exit $1
                      }
                      log_output() {
                        local data=''
                        local summary=''
                        if test -f "${1}"; then
                          data=$(cat "${1}")
                        fi
                        if test -n "${2}"; then
                          summary="The ${LOG_NAME} failed❗ ${2}"
                          if test -n "${3}"; then
                            summary+="\n\nCommand that failed:\n${3}"
                          fi
                        elif test -z "${data}"; then
                          summary="The ${LOG_NAME} failed❗ No output found."
                        else
                          summary="The ${LOG_NAME} completed successfully ✅"
                        fi
                        local output="## Resource provider\n\n${summary}"
                        if test -n "${data}"; then
                          output+='\n\n<details><summary>Click for details</summary>'
                          output+='\n\n```text\n'
                          output+="${data}\n"
                          output+='```'
                          output+='\n\n</details>'
                        fi
                        echo -e "${output}" > "${1/.log/.md}"
                      }
                      if test -n "${IN_PROVIDERS}"; then
                        providers=($(echo "${IN_PROVIDERS}" | tr ' ' '\n' | sort -u))
                        declare -a checkProviders=()
                        case "${IN_SEVERITY}" in
                          ERROR)   log_severity=' --only-show-errors';;
                          VERBOSE) log_severity=' --verbose';;
                          DEBUG)   log_severity=' --debug';;
                          *)       log_severity='';;
                        esac
                        echo 'Check resource providers...'
                        registered=($(
                          az provider list \
                            --query "[?registrationState=='Registered'].namespace" \
                            -o tsv $log_severity
                        ))
                        if test -z "${registered[*]}"; then
                          echo 'Could not find any registered providers!' | tee -a "${log}"
                        else
                          echo 'Currently registered:' | tee -a "${log}"
                          echo -e "- $(echo "${registered[*]}" | sed 's/ /\n- /g')\n" | tee -a "${log}"
                          registered=$(echo "${registered[*]}" | tr '[:upper:]' '[:lower:]')
                        fi
                        for provider in "${providers[@]}"; do
                          value=$(echo " ${provider} " | tr '[:upper:]' '[:lower:]')
                          if [[ ! " ${registered} " =~ ${value} ]]; then
                            echo "Register ${provider}..." | tee -a "${log}"
                            az provider register \
                              --consent-to-permissions --namespace $provider \
                              ${log_severity} 1> >(tee -a "${log}") 2> >(tee -a "${log}" >&2)
                            checkProviders+=($provider)
                          fi
                        done
                        if [ ${#checkProviders} -eq 0 ]; then
                          echo 'All providers registered!' | tee -a "${log}"
                        else
                          for provider in "${checkProviders[@]}"; do
                            state='Registering'
                            timesTried=0
                            while [ "${state}" != 'Registered' ] || \
                                  [ $timesTried -gt $WAIT_COUNT ]
                            do
                              echo "Waiting for ${provider} to register..."
                              state=$(
                                az provider show --namespace $provider \
                                  --query 'registrationState' -o tsv \
                                  $log_severity 1> >(tee -a "${log}") 2> >(tee -a "${log}" >&2)
                              )
                              timesTried=$(expr $timesTried + 1)
                              sleep $WAIT_SECONDS
                            done
                            if ! [ "${state}" = 'Registered' ]; then
                              echo "Timeout: ${provider} in ${state} state..." | tee -a "${log}"
                            else
                              echo 'Providers successfully registered!' | tee -a "${log}"
                            fi
                          done
                        fi
                      fi
                      log_output "${log}" '' ''

                - task: AzureCLI@2
                  displayName: Deploy
                  env:
                    IN_LOCATION: ${{ variables.location }}
                    IN_MANAGEMENT_GROUP: ${{ variables.management_group }}
                    IN_RESOURCE_GROUP: ${{ variables.resource_group }}
                    IN_SCOPE: ${{ variables.scope }}
                    IN_SEVERITY: ${{ variables.log_severity }}
                    IN_TEMPLATE: ${{ variables.template }}
                    IN_TEMPLATE_PARAMS: ${{ variables.template_parameters }}
                    LOG_NAME: deploy
                    LOG_PATH: $(Pipeline.Workspace)/logs
                    RUN_ID: $(Build.BuildId)
                    RUN_NAME: $(Build.BuildNumber)
                    RUN_NUMBER: $(Build.BuildId)
                    SOURCE_PATH: $(Build.SourcesDirectory)
                    SUBSCRIPTION_ID: ${{ variables.azure_subscription_id }}
                  name: deploy
                  inputs:
                    azureSubscription: ${{ variables.serviceConnection }}
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      set -e
                      log="${LOG_PATH}/step_a1_${LOG_NAME}.log"
                      trap 'error_handler $? $LINENO "$BASH_COMMAND" $log' ERR
                      error_handler() {
                        local msg="Error on or near line $(expr $2 + 1) (exit code $1)"
                        msg+=" in ${LOG_NAME} at $(date '+%Y-%m-%d %H:%M:%S')"
                        echo "${msg}"
                        log_output "$4" "${msg}" "$3"
                        exit $1
                      }
                      log_output() {
                        local data=''
                        local errors=''
                        local json_object=''
                        local summary=''
                        local warnings=''
                        if test -f "${1}"; then
                          data=$(cat "${1}")
                        fi
                        if test -f "${1/.log/.json}"; then
                          json_object=$(sed -n '/^{$/,$p' "${1/.log/.json}")
                          local json_content=$(sed '/^{$/,$d' "${1/.log/.json}")
                          json_content=$(echo "${json_content//${SOURCE_PATH}/}")
                          warnings=$(echo "${json_content}" | sed -n -e '/) : Warning /p')
                          warnings=$(echo "${warnings//WARNING: /}")
                          errors=$(echo "${json_content}" | sed -n '/^ERROR: /,$p')
                          errors=$(echo "${errors//ERROR: /}")
                        fi
                        if test -n "${errors}" || test -n "${2}"; then
                          summary=" ${2}"
                          if test -n "${3}"; then
                            summary+="\n\nCommand that failed:\n${3}"
                          fi
                        elif test -n "${warnings}"; then
                          summary=" Notice the ${LOG_NAME} warning ✋"
                        elif test -z "${json_object}"; then
                          summary=" No output found."
                        fi
                        local output="# ${RUN_NAME} #${RUN_NUMBER}\n\n_JOB_STATUS_${summary}"
                        if test -n "${data}"; then
                          output+='\n\n```text\n'
                          output+="${data}\n"
                          output+='```'
                        fi
                        if test -n "${warnings}"; then
                          output+='\n\nWARNINGS:\n\n```text\n'
                          output+="${warnings}\n"
                          output+='```'
                        fi
                        if test -n "${errors}"; then
                          output+='\n\nERRORS:\n\n```text\n'
                          output+="${errors}\n"
                          output+='```'
                        fi
                        if test -n "${json_object}"; then
                          output+='\n\n<details><summary>Click for details</summary>'
                          output+='\n\n```json\n'
                          output+="${json_object}\n"
                          output+='```\n\n</details>'
                        fi
                        echo -e "${output}" > "${1/.log/.md}"
                      }
                      az account set -s ${SUBSCRIPTION_ID} 1> >(tee -a "${log}") 2> >(tee -a "${log}" >&2)
                      if [[ $IN_TEMPLATE_PARAMS == http* ]]; then
                        file="${IN_TEMPLATE_PARAMS%% *}"
                        curl -o "${file##*/}" -sSL "${file}" 1> >(tee -a "${log}") 2> >(tee -a "${log}" >&2)
                        IN_TEMPLATE_PARAMS="${IN_TEMPLATE_PARAMS/${file}/${file##*/}}"
                      fi
                      cmd="az deployment ${IN_SCOPE} create --name ${LOG_NAME}_${RUN_ID}"
                      if [[ $IN_TEMPLATE == http* ]]; then
                        cmd+=" --template-uri ${IN_TEMPLATE}"
                      elif [[ $IN_TEMPLATE == /subscriptions/* ]]; then
                        cmd+=" --template-spec ${IN_TEMPLATE}"
                      else
                        cmd+=" --template-file ${IN_TEMPLATE}"
                      fi
                      if test -n "${IN_TEMPLATE_PARAMS}"; then
                        cmd+=" --parameters ${IN_TEMPLATE_PARAMS}"
                      fi
                      if ! [ "${IN_SCOPE}" = 'group' ]; then
                        cmd+=" --location ${IN_LOCATION}"
                      fi
                      if [ "${IN_SCOPE}" = 'mg' ]; then
                        cmd+=" --management-group-id ${IN_MANAGEMENT_GROUP}"
                      fi
                      if [ "${IN_SCOPE}" = 'group' ]; then
                        cmd+=" --resource-group ${IN_RESOURCE_GROUP}"
                      fi
                      case "${IN_SEVERITY}" in
                        ERROR)   cmd+=' --only-show-errors';;
                        VERBOSE) cmd+=' --verbose';;
                        DEBUG)   cmd+=' --debug';;
                      esac
                      cmd+=' --no-prompt true'
                      echo "Run: ${cmd}"
                      eval "${cmd}" 1> >(tee -a "${log/.log/.json}") 2> >(tee -a "${log}" >&2)
                      log_output "${log}" '' ''

                - task: Bash@3
                  condition: and(always(), eq(variables['Build.Reason'], 'PullRequest'))
                  displayName: Add comment
                  env:
                    JOB_STATUS: $(Agent.JobStatus)
                    LOG_PATH: $(Pipeline.Workspace)/logs
                    RUN_NUMBER: $(Build.BuildId)
                    RUN_URL: $(Build.BuildUri)
                    TOKEN: $(System.AccessToken)
                  name: add_comment
                  inputs:
                    targetType: inline
                    script: |
                      set -e
                      add_output() {
                        local add=''
                        local data=''
                        local name=''
                        local step=''
                        local output=''
                        while read -r file; do
                          data=$(cat "${file}")
                          if test -n "${data}"; then
                            name=$(basename "${file}")
                            name=${name:8}
                            name=${name/_/ }
                            name=${name/psrule/PSRule}
                            name=${name/.md/}
                            name="$(tr '[:lower:]' '[:upper:]' <<< ${name:0:1})${name:1}"
                            step=$(printf '%20s' "'${name}'")
                            add=$(printf '%5d' ${#data})
                            if [ ${#data} -gt 63900 ]; then
                              data=$(echo -e "## ${name}\n\nThe ${name} output is too long. See job [#${RUN_NUMBER}](${RUN_URL}) for details!")
                            fi
                            if test -z "${output}"; then
                              output=$data
                            else
                              output+=$(echo -e "\n\n${data}")
                            fi
                          fi
                        done
                        echo "$output"
                      }
                      output=$(find $LOG_PATH -name 'step_*.md' -maxdepth 1 -type f | sort | add_output)
                      case "${JOB_STATUS}" in
                        cancelled|Canceled) title='The job was cancelled ❎';;
                        failed|Failed)      title='The job failed ⛔';;
                        *)                  title='The job completed successfully ✅';;
                      esac
                      if test -z "${output}"; then
                        title+=' Job output is missing ⭕'
                      fi
                      output="${output/_JOB_STATUS_/${title}}"
                      echo "Comment has ${#output} characters."
                      echo "${output}" > "${LOG_PATH}/comment.md"
                      echo "##vso[task.uploadsummary]${LOG_PATH}/comment.md"
                      uri=$(echo "$(System.CollectionUri)$(System.TeamProject)/_apis/git/repositories/$(Build.Repository.Name)/pullRequests/$(System.PullRequest.PullRequestId)/threads?api-version=7.1-preview.1")
                      data=$(jq --arg content "$output" '.comments[0].content = $content' <<< '{"comments": [{"parentCommentId": 0,"content": "","commentType": 1}],"status": 1}')
                      HTTP_CODE=$(curl --request POST \
                        --write-out "%{http_code}" \
                        --header 'Accept: application/json' \
                        --header "Authorization: Bearer ${TOKEN}" \
                        --header 'Content-Type: application/json' \
                        --data "${data}" \
                        --url "$( echo "$uri" | sed 's/ /%20/g' )" \
                        --output "${LOG_PATH}/add_comment.log" --silent
                      )
                      if [[ ${HTTP_CODE} -lt 200 || ${HTTP_CODE} -gt 299 ]]; then
                        echo "Unable to create comment! Response code: ${HTTP_CODE}"
                        if test -f "${LOG_PATH}/add_comment.log"; then
                          cat "${LOG_PATH}/add_comment.log"
                        fi
                        exit 1
                      fi

                - task: Bash@3
                  condition: or(failed(), and(succeeded(), not(eq(variables['log_severity'], 'ERROR'))))
                  displayName: Show debug info
                  name: debug
                  inputs:
                    targetType: inline
                    script: |
                      set -e
                      echo '##[group]environment variables'
                      for var in $(compgen -e); do
                        echo "${var} ${!var}"
                      done
                      echo '##[endgroup]'

                - task: PublishPipelineArtifact@1
                  name: upload_logs
                  displayName: Upload logs
                  condition: always()
                  inputs:
                    targetPath: $(Pipeline.Workspace)/logs
                    artifact: deploy_logs
                    publishLocation: pipeline
